Anti Aliasing
---separator---
May 2, 2019
---separator---
May 2, 2019
---separator---

<style>
</style>

---separator---

<canvas id="canvas" width="640" height="480"></canvas>

<div>
  <select id="anti-aliasing">
    <option value="No AA">No AA</option>
    <option value="MSAA" selected="selected">MSAA</option>
    <option value="TAA">TAA</option>
  </select>
</div>

---separator---

<script>

  function main() {
		var request = new XMLHttpRequest();
		request.open('GET', '/data/fence_01.obj', false);
		request.send();
		var obj = load_obj(request.responseText);

		var canvas = document.querySelector("#canvas");

		var gl = canvas.getContext("webgl2", {antialias: false});
		if (gl === null) {
			alert("Unable to initialize WebGL2. Your browser or machine may not support it.");
			return;
		}

		var vert_shader_src = `
      attribute vec3 position;
      attribute vec3 normal;
      uniform mat4 model_mat;
      uniform mat4 view_mat;
      uniform mat4 proj_mat;
      varying vec3 t_normal;
      void main() {
        t_normal = mat3(model_mat) * normal;
        gl_Position = proj_mat * view_mat * model_mat * vec4(position, 1);
      }
    `;

		var frag_shader_src = `
      precision mediump float;
      varying vec3 t_normal;
      void main() {
        gl_FragColor = vec4(1, 1, 1, 1);
      }
    `;
		
		var vert_shader = gl.createShader(gl.VERTEX_SHADER);
		var frag_shader = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(vert_shader, vert_shader_src);
		gl.shaderSource(frag_shader, frag_shader_src);
		gl.compileShader(vert_shader);
		gl.compileShader(frag_shader);
		console.log("vert_shader status: " + gl.getShaderInfoLog(vert_shader));
		console.log("frag_shader status: " + gl.getShaderInfoLog(frag_shader));

		var shader = gl.createProgram();
		gl.attachShader(shader, vert_shader);
		gl.attachShader(shader, frag_shader);
		gl.linkProgram(shader);
		console.log("shader status: " + gl.getProgramInfoLog(shader));

		var shader_info = {
			position : gl.getAttribLocation(shader, "position"),
			normal : gl.getAttribLocation(shader, "normal"),
			model_mat : gl.getUniformLocation(shader, 'model_mat'),
			view_mat : gl.getUniformLocation(shader, 'view_mat'),
			proj_mat : gl.getUniformLocation(shader, 'proj_mat'),
		};

		var vertex_buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(obj.vertices), gl.STATIC_DRAW);

		var msaa_renderbuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, msaa_renderbuffer);
		gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 8, gl.RGBA8, gl.canvas.clientWidth, gl.canvas.clientHeight);

		var msaa_renderbuffer_depth = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER, msaa_renderbuffer_depth);
		gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 8, gl.DEPTH_COMPONENT24, gl.canvas.clientWidth, gl.canvas.clientHeight);

		var msaa_framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, msaa_framebuffer);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaa_renderbuffer);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, msaa_renderbuffer_depth);

    var msaa_resolve_texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, msaa_resolve_texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
		
		var msaa_resolve_framebuffer = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, msaa_resolve_framebuffer);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, msaa_resolve_texture, 0);
		
		function render(now) {
			var model_mat = mat4_identity();
			var view_mat = mat4_view([675, 600, 500], [25, 0, -250]);
			var fovy = deg_to_rad(45);
			var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
			var proj_mat = mat4_perspective(fovy, aspect, 0.1, 10000);
			
			var aa = anti_aliasing.options[anti_aliasing.selectedIndex].value;
			if (aa === "No AA") {
				gl.useProgram(shader);

				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
				
				gl.clearColor(0, 0, 0, 1);
				gl.clearDepth(1);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
				gl.vertexAttribPointer(shader_info.position, 3, gl.FLOAT, false, 32, 0);
				gl.vertexAttribPointer(shader_info.normal, 3, gl.FLOAT, false, 32, 12);
				gl.enableVertexAttribArray(shader_info.position);
				gl.enableVertexAttribArray(shader_info.normal);

				gl.uniformMatrix4fv(shader_info.model_mat, false, model_mat);
				gl.uniformMatrix4fv(shader_info.view_mat, false, view_mat);
				gl.uniformMatrix4fv(shader_info.proj_mat, false, proj_mat);

				gl.drawArrays(gl.TRIANGLES, 0, obj.vertices.length / 8);
			}
			else if (aa === "MSAA") {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, msaa_framebuffer);
				gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
				gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);

				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);

				gl.useProgram(shader);

				gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
				gl.vertexAttribPointer(shader_info.position, 3, gl.FLOAT, false, 32, 0);
				gl.vertexAttribPointer(shader_info.normal, 3, gl.FLOAT, false, 32, 12);
				gl.enableVertexAttribArray(shader_info.position);
				gl.enableVertexAttribArray(shader_info.normal);

				gl.uniformMatrix4fv(shader_info.model_mat, false, model_mat);
				gl.uniformMatrix4fv(shader_info.view_mat, false, view_mat);
				gl.uniformMatrix4fv(shader_info.proj_mat, false, proj_mat);

				gl.drawArrays(gl.TRIANGLES, 0, obj.vertices.length / 8);

				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, msaa_framebuffer);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);

				gl.clearColor(0, 0, 0, 1);
				gl.clearDepth(1);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.blitFramebuffer(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight,
													 0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight,
													 gl.COLOR_BUFFER_BIT, gl.NEAREST);
			}
			else if (aa === "TAA") {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, msaa_framebuffer);
				gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
				gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);

				gl.enable(gl.DEPTH_TEST);
				gl.depthFunc(gl.LEQUAL);

				gl.useProgram(shader);

				gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
				gl.vertexAttribPointer(shader_info.position, 3, gl.FLOAT, false, 32, 0);
				gl.vertexAttribPointer(shader_info.normal, 3, gl.FLOAT, false, 32, 12);
				gl.enableVertexAttribArray(shader_info.position);
				gl.enableVertexAttribArray(shader_info.normal);

				gl.uniformMatrix4fv(shader_info.model_mat, false, model_mat);
				gl.uniformMatrix4fv(shader_info.view_mat, false, view_mat);
				gl.uniformMatrix4fv(shader_info.proj_mat, false, proj_mat);

				gl.drawArrays(gl.TRIANGLES, 0, obj.vertices.length / 8);

				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, msaa_framebuffer);
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);

				gl.clearColor(0, 0, 0, 1);
				gl.clearDepth(1);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.blitFramebuffer(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight,
													 0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight,
													 gl.COLOR_BUFFER_BIT, gl.NEAREST);
			}
		}

		requestAnimationFrame(render);

		var anti_aliasing = document.getElementById("anti-aliasing");
		anti_aliasing.addEventListener("change", function() {
			requestAnimationFrame(render);
		});
	};

	main();
</script>
